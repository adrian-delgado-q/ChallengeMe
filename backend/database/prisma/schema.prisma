generator client {
  provider = "prisma-client-js"
  output   = "../prisma-generated-client"
}

datasource db {
  provider = "postgresql"
  url      = env("SUPABASE_DB_URL")
}

// --- Enums ---
enum TeamRole {
  ADMIN
  MEMBER
}

enum ChallengeParticipantType {
  INDIVIDUAL
  TEAM
}

// --- Models ---

// NOTE: This model is a representation of your external `auth.users` table.
// Defining it here allows Prisma to create explicit, type-safe relationships
// with the rest of your schema.
model User {
  id String @id @db.Uuid

  // Relationships back to other models
  createdTeams      Team[]                 @relation("TeamCreator")
  teamMemberships   TeamMembership[]
  createdChallenges Challenge[]            @relation("ChallengeCreator")
  challengeEntries  ChallengeParticipant[]
  activities        Activity[]
  posts             Post[]
  comments          Comment[]
}

model Team {
  id          String    @id @default(uuid()) @db.Uuid
  creatorId   String    @db.Uuid
  name        String
  description String?
  avatarUrl   String?
  isPublic    Boolean   @default(true)
  createdAt   DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt   DateTime? @db.Timestamptz(6)

  // Explicit relation to the User model
  creator          User                   @relation("TeamCreator", fields: [creatorId], references: [id])
  // Relation to the join table for members
  teamMemberships  TeamMembership[]
  // A team can participate in multiple challenges
  challengeEntries ChallengeParticipant[]
}

model TeamMembership {
  id        String    @id @default(uuid()) @db.Uuid
  teamId    String    @db.Uuid
  userId    String    @db.Uuid
  role      TeamRole  @default(MEMBER)
  joinedAt  DateTime  @default(now()) @db.Timestamptz(6)
  expiresAt DateTime? @db.Timestamptz(6)

  // Explicit relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // This unique constraint is excellent for preventing duplicate memberships.
  @@unique([teamId, userId])
}

model Challenge {
  id              String                   @id @default(uuid()) @db.Uuid
  creatorId       String                   @db.Uuid
  title           String
  description     String?
  challengeType   ChallengeParticipantType @default(INDIVIDUAL)
  maxParticipants Int?
  startDate       DateTime                 @db.Date
  endDate         DateTime                 @db.Date
  isPublic        Boolean                  @default(true)
  createdAt       DateTime                 @default(now()) @db.Timestamptz(6)
  expiresAt       DateTime?                @db.Timestamptz(6)

  // Explicit relations
  creator      User                   @relation("ChallengeCreator", fields: [creatorId], references: [id])
  participants ChallengeParticipant[]
  activities   Activity[]
  posts        Post[]
}

// CORE Refactored to remove the ambiguous polymorphic relation.
model ChallengeParticipant {
  id          String   @id @default(uuid()) @db.Uuid
  challengeId String   @db.Uuid
  // Each participant is EITHER a user OR a team, but not both.
  // One of these fields will be populated, the other will be null.
  userId      String?  @db.Uuid
  teamId      String?  @db.Uuid
  joinedAt    DateTime @default(now()) @db.Timestamptz(6)

  // Explicit relations
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user      User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  team      Team?     @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // An activity or post is created by a participant of a challenge.
  activities Activity[]
  posts      Post[]

  // Ensures a user or team can't join the same challenge twice.
  @@unique([challengeId, userId])
  @@unique([challengeId, teamId])
}

model Activity {
  id            String   @id @default(uuid()) @db.Uuid
  //An activity is logged by a specific participant in a challenge.
  participantId String   @db.Uuid
  notes         String?
  date          DateTime @db.Date
  uploadedAt    DateTime @default(now()) @db.Timestamptz(6)

  // Explicit relation to the participant entry
  participant ChallengeParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  User        User?                @relation(fields: [userId], references: [id])
  userId      String?              @db.Uuid
  Challenge   Challenge?           @relation(fields: [challengeId], references: [id])
  challengeId String?              @db.Uuid
}

model Post {
  id            String   @id @default(uuid()) @db.Uuid
  // A post is created by a specific participant in a challenge.
  participantId String   @db.Uuid
  content       String?
  imageUrl      String?
  createdAt     DateTime @default(now()) @db.Timestamptz(6)

  // Explicit relation to the participant entry
  participant ChallengeParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  comments    Comment[]
  User        User?                @relation(fields: [userId], references: [id])
  userId      String?              @db.Uuid
  Challenge   Challenge?           @relation(fields: [challengeId], references: [id])
  challengeId String?              @db.Uuid
}

model Comment {
  id        String   @id @default(uuid()) @db.Uuid
  // A comment is always from an individual user, even on a team's post.
  authorId  String   @db.Uuid
  postId    String   @db.Uuid
  content   String?
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  // Explicit relations
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
}
